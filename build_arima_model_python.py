# -*- coding: utf-8 -*-
"""Build ARIMA Model Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zCSgBy7zP3HvvIQ_6Q_fM3fvD7Nua4bk
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, r2_score

def preprocess_data(ticker, start_date, end_date, look_back):
    # Fetch data
    data = yf.download(ticker, start=start_date, end=end_date, interval='1d')
    data['Close'].fillna(method='ffill', inplace=True)

    # Normalize data
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(data['Close'].values.reshape(-1, 1))

    # Prepare LSTM training data
    X_train, y_train = [], []
    for i in range(look_back, len(scaled_data)):
        X_train.append(scaled_data[i-look_back:i, 0])
        y_train.append(scaled_data[i, 0])

    X_train, y_train = np.array(X_train), np.array(y_train)
    X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
    return data, scaler, X_train, y_train

def build_lstm_model(input_shape):
    model = Sequential()
    model.add(LSTM(units=50, return_sequences=True, input_shape=input_shape))
    model.add(LSTM(units=50, return_sequences=False))
    model.add(Dense(units=1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

def arima_model_fit(data):
    model = ARIMA(data, order=(5, 1, 0))
    result = model.fit()
    return result

def plot_results(data, look_back, lstm_predictions, arima_predictions, combined_predictions):
    plt.figure(figsize=(14, 7))
    plt.plot(data.index[look_back:], data['Close'][look_back:], label='Actual Prices', color='blue')
    plt.plot(data.index[look_back:], lstm_predictions, label='LSTM Predictions', color='orange')
    plt.plot(data.index[look_back:], arima_predictions, label='ARIMA Predictions', color='green')
    plt.plot(data.index[look_back:], combined_predictions, label='Combined Predictions', color='red')
    plt.title('Stock Price Prediction with LSTM and ARIMA')
    plt.xlabel('Date')
    plt.ylabel('Stock Price (USD)')
    plt.legend()
    plt.show()

def main():
    ticker = 'AAPL'
    start_date = '2015-01-01'
    end_date = '2024-12-31'
    look_back = 60

    # Preprocessing
    data, scaler, X_train, y_train = preprocess_data(ticker, start_date, end_date, look_back)

    # Train LSTM model
    lstm_model = build_lstm_model((X_train.shape[1], 1))
    lstm_model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0)

    # Predict using LSTM
    lstm_predictions = lstm_model.predict(X_train)
    lstm_predictions = scaler.inverse_transform(lstm_predictions)
    y_train_actual = scaler.inverse_transform(y_train.reshape(-1, 1))

    # Train ARIMA model
    arima_result = arima_model_fit(data['Close'])
    arima_predictions = arima_result.predict(start=look_back, end=len(data) - 1, dynamic=False)

    # Combine predictions
    combined_predictions = 0.5 * lstm_predictions.flatten() + 0.5 * arima_predictions.values

    # Calculate metrics
    lstm_mse = mean_squared_error(y_train_actual, lstm_predictions)
    arima_mse = mean_squared_error(data['Close'][look_back:], arima_predictions)
    combined_mse = mean_squared_error(data['Close'][look_back:], combined_predictions)
    r2 = r2_score(data['Close'][look_back:], combined_predictions)

    # Print metrics
    print(f"LSTM MSE: {lstm_mse:.4f}")
    print(f"ARIMA MSE: {arima_mse:.4f}")
    print(f"Combined MSE: {combined_mse:.4f}")
    print(f"R-squared: {r2:.4f}")

    # Plot results
    plot_results(data, look_back, lstm_predictions, arima_predictions, combined_predictions)

if __name__ == "__main__":
    main()

!pip install pandas numpy matplotlib statsmodels yfinance pmdarima

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from pmdarima import auto_arima

# Step 1: Load Data
ticker = 'AAPL'
data = yf.download(ticker, start='2010-01-01', end='2024-12-31')

# Use the 'Close' price for prediction and reset index
data = data[['Close']].reset_index()

# Step 2: Preprocess Data
data.columns = ['ds', 'y']

# Add moving average as a feature
data['SMA_10'] = data['y'].rolling(window=10).mean()
data['SMA_50'] = data['y'].rolling(window=50).mean()

# Fill missing values in moving averages
data.fillna(method='bfill', inplace=True)

# Apply log transformation to stabilize variance
data['y_log'] = np.log(data['y'])

# Step 3: Auto ARIMA for Parameter Selection
auto_model = auto_arima(data['y_log'],
                        seasonal=True,
                        m=12,
                        trace=True,
                        error_action='ignore',
                        suppress_warnings=True)

# Extract the best parameters
order = auto_model.order
seasonal_order = auto_model.seasonal_order

print(f"Optimal Order: {order}")
print(f"Optimal Seasonal Order: {seasonal_order}")

# Step 4: Fit the SARIMA Model
model = SARIMAX(data['y_log'], order=order, seasonal_order=seasonal_order)
model_fit = model.fit(disp=False)

# Step 5: Future Price Prediction
future_steps = 70
forecast = model_fit.get_forecast(steps=future_steps)

# Generate future dates
last_date = data['ds'].iloc[-1]
future_dates = pd.date_range(last_date + pd.Timedelta(days=1), periods=future_steps)

# Get forecasted values and confidence intervals
future_prices_log = forecast.predicted_mean
conf_int = forecast.conf_int()

# Transform predictions back to original scale
future_prices = np.exp(future_prices_log)
conf_int_original = np.exp(conf_int)

# Step 6: Calculate Metrics
forecast_steps = 100
rolling_predictions = []
actual_values = data['y_log'][-forecast_steps:]

for i in range(forecast_steps):
    train_data = data['y_log'][:len(data) - forecast_steps + i]
    model = SARIMAX(train_data, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)
    forecast = model_fit.get_forecast(steps=1).predicted_mean
    rolling_predictions.append(forecast.values[0])

# Transform predictions back to original scale
rolling_predictions = np.exp(rolling_predictions)
actual_values = np.exp(actual_values)

mae = mean_absolute_error(actual_values, rolling_predictions)
mse = mean_squared_error(actual_values, rolling_predictions)
rmse = np.sqrt(mse)
r2 = r2_score(actual_values, rolling_predictions)

print(f'Mean Absolute Error: {mae}')
print(f'Mean Squared Error: {mse}')
print(f'Root Mean Squared Error: {rmse}')
print(f'R-squared: {r2}')

# Step 7: Visualize Actual vs Rolling Predictions
plt.figure(figsize=(12, 6))
plt.plot(data['ds'], data['y'], label='Actual Prices', color='blue')
plt.plot(data['ds'][-forecast_steps:], rolling_predictions, label='Predicted Prices (Validation)', color='red')
plt.title(f'{ticker} Stock Price Prediction using SARIMA (Validation)')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# Step 8: Visualize Future Predictions
plt.figure(figsize=(12, 6))
plt.plot(data['ds'], data['y'], label='Historical Prices', color='blue')
plt.plot(future_dates, future_prices, label='Future Predictions', color='green')
plt.fill_between(future_dates,
                 conf_int_original.iloc[:, 0],
                 conf_int_original.iloc[:, 1], color='lightgreen', alpha=0.3)
plt.title(f'{ticker} Stock Price Forecast using SARIMA')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

